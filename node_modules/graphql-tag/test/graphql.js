const gql = require('../src');
const loader = require('../loader');
const assert = require('chai').assert;

describe('gql', () => {
  it('parses queries', () => {
    assert.equal(gql`{ testQuery }`.kind, 'Document');
  });

  it('parses queries when called as a function', () => {
    assert.equal(gql('{ testQuery }').kind, 'Document');
  });

  it('parses queries with weird substitutions', () => {
    const obj = {};
    assert.equal(gql`{ field(input: "${obj.missing}") }`.kind, 'Document');
    assert.equal(gql`{ field(input: "${null}") }`.kind, 'Document');
    assert.equal(gql`{ field(input: "${0}") }`.kind, 'Document');
  });

  it('allows interpolation of documents generated by the webpack loader', () => {
    const sameFragment = "fragment SomeFragmentName on SomeType { someField }";

    const jsSource = loader.call(
      { cacheable() {} },
      "fragment SomeFragmentName on SomeType { someField }"
    );
    const module = { exports: undefined };
    eval(jsSource);

    const document = gql`query { ...SomeFragmentName } ${module.exports}`;
    assert.equal(document.kind, 'Document');
    assert.equal(document.definitions.length, 2);
    assert.equal(document.definitions[0].kind, 'OperationDefinition');
    assert.equal(document.definitions[1].kind, 'FragmentDefinition');
  });

  it('parses queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, '{ testQuery }');
    const module = { exports: undefined };
    eval(jsSource);
    assert.equal(module.exports.kind, 'Document');
  });

  it('parses single query through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.equal(module.exports.kind, 'Document');
    assert.exists(module.exports.Q1);
    assert.equal(module.exports.Q1.kind, 'Document');
    assert.equal(module.exports.Q1.definitions.length, 1);
  });

  it('parses single query and exports as default', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.deepEqual(module.exports.definitions, module.exports.Q1.definitions);
  });

  it('parses multiple queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
      query Q2 { testQuery2 }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);
    assert.equal(module.exports.Q1.kind, 'Document');
    assert.equal(module.exports.Q2.kind, 'Document');
    assert.equal(module.exports.Q1.definitions.length, 1);
    assert.equal(module.exports.Q2.definitions.length, 1);
  });

  it('parses fragments with variable definitions', () => {
    gql.enableExperimentalFragmentVariables();

    const parsed = gql`fragment A ($arg: String!) on Type { testQuery }`;
    assert.equal(parsed.kind, 'Document');
    assert.exists(parsed.definitions[0].variableDefinitions);

    gql.disableExperimentalFragmentVariables()
  });

  // see https://github.com/apollographql/graphql-tag/issues/168
  it('does not nest queries needlessly in named exports', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
      query Q2 { testQuery2 }
      query Q3 { test Query3 }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.notExists(module.exports.Q2.Q1);
    assert.notExists(module.exports.Q3.Q1);
    assert.notExists(module.exports.Q3.Q2);
  });

  it('tracks fragment dependencies from multiple queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      fragment F1 on F { testQuery }
      fragment F2 on F { testQuery2 }
      fragment F3 on F { testQuery3 }
      query Q1 { ...F1 }
      query Q2 { ...F2 }
      query Q3 {
        ...F1
        ...F2
      }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);
    assert.exists(module.exports.Q3);
    const Q1 = module.exports.Q1.definitions;
    const Q2 = module.exports.Q2.definitions;
    const Q3 = module.exports.Q3.definitions;

    assert.equal(Q1.length, 2);
    assert.equal(Q1[0].name.value, 'Q1');
    assert.equal(Q1[1].name.value, 'F1');

    assert.equal(Q2.length, 2);
    assert.equal(Q2[0].name.value, 'Q2');
    assert.equal(Q2[1].name.value, 'F2');

    assert.equal(Q3.length, 3);
    assert.equal(Q3[0].name.value, 'Q3');
    assert.equal(Q3[1].name.value, 'F1');
    assert.equal(Q3[2].name.value, 'F2');

  });

  it('tracks fragment dependencies across nested fragments', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      fragment F11 on F { testQuery }
      fragment F22 on F {
        ...F11
        testQuery2
      }
      fragment F33 on F {
        ...F22
        testQuery3
      }

      query Q1 {
        ...F33
      }

      query Q2 {
        id
      }
    `);

    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);

    const Q1 = module.exports.Q1.definitions;
    const Q2 = module.exports.Q2.definitions;

    assert.equal(Q1.length, 4);
    assert.equal(Q1[0].name.value, 'Q1');
    assert.equal(Q1[1].name.value, 'F33');
    assert.equal(Q1[2].name.value, 'F22');
    assert.equal(Q1[3].name.value, 'F11');

    assert.equal(Q2.length, 1);
  });

  it('correct